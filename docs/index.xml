<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jiegao on Jiegao</title>
    <link>https://hestation.com/</link>
    <description>Recent content in Jiegao on Jiegao</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 Jul 2019 10:47:06 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Hello, Hugo</title>
      <link>https://hestation.com/2019/hugo/</link>
      <pubDate>Wed, 17 Jul 2019 10:47:06 +0800</pubDate>
      
      <guid>https://hestation.com/2019/hugo/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;记得是 16 年还在学校的时候开始折腾博客这个东西，而当时就觉得市面上所有现成的博客系统都做得不大好，要么太丑，要么太重。所以从一开始就走上了自建这么一条不归路，从买服务器，买域名，到接触不同的 Linux 系统，折腾过程中踩了很多坑，但也因此学会了很多东西。如今工作之后，由于没有继续干开发的工作，也很少花时间在这上面了，而以前写的一些东西也因此丢了，心里还是有点难过的。前两天突然心血来潮，觉着这种方式相比朋友圈、微博 Twitter 等东西，更能将过去的一些经验、日常沉淀下来，日后来看，说不定别有另一番滋味，于是，开搞。&lt;/p&gt;

&lt;p&gt;记得之前最后一个版本的博客是基于 Hexo 搞的，整体来讲还是不错的，不过记忆中那一堆 Nodejs 的依赖，各种乱七八糟的小问题，折腾了好久，再加上确实当内容多起来之后，每次编译生成的速度会比较慢，所以想着换一个试试，网上搜了一大圈，不少人都推荐 Hugo，于是做了下尝试，确实不错，暂时就用它了。以下是重新用它搭建的整体流程记录。&lt;/p&gt;

&lt;h2 id=&#34;本地安装&#34;&gt;本地安装&lt;/h2&gt;

&lt;h3 id=&#34;整个流程如下&#34;&gt;整个流程如下：&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;安装 Hugo&lt;/code&gt; -&amp;gt; &lt;code&gt;新建站点&lt;/code&gt; -&amp;gt; &lt;code&gt;选择并拷贝主题到 themes 目录&lt;/code&gt; -&amp;gt; &lt;code&gt;修改站点配置文件&lt;/code&gt; -&amp;gt; &lt;code&gt;本地测试运行&lt;/code&gt; -&amp;gt; &lt;code&gt;完成&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;整个站点各个目录的作用&#34;&gt;整个站点各个目录的作用：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;archetypes：给不同的类型定义默认FrontMatter，&lt;/li&gt;
&lt;li&gt;content：源文件，相当于 hexo 的 source 目录&lt;/li&gt;
&lt;li&gt;data：数据文件，一般用不上&lt;/li&gt;
&lt;li&gt;layouts：模板&lt;/li&gt;
&lt;li&gt;static：静态资源，也就是不需要Hugo处理的静态资源，比如图片等&lt;/li&gt;
&lt;li&gt;themes：第三方主题，将第三方主题拷贝到这个文件夹下即可使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;参考资料&#34;&gt;参考资料：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/documentation/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Hugo Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/liuzc/LeaveIt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Hugo LeaveIt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;部署上线&#34;&gt;部署上线&lt;/h2&gt;

&lt;p&gt;这里还是选择了部署在 Github Pages 上，因为方便且能很好地管理源文件。&lt;/p&gt;

&lt;p&gt;本地测试确认没问题后，直接在站点目录下输入命令 &lt;code&gt;hugo&lt;/code&gt; 即可编译，然后将所有内容 push 到 GitHub 上即可。&lt;/p&gt;

&lt;p&gt;由于 Hugo 提供了另一种方式来管理源代码与站点文件，即在配置文件 &lt;code&gt;config.yoml&lt;/code&gt; 中加一条 &lt;code&gt;publishDir = &amp;quot;docs&amp;quot;&lt;/code&gt; 的选项，便可把所有编译生成的站点文件放在docs文件夹里，而 GitHub 能在设置中手动将 Pages 的目录选为 docs，这样便能达成一次 push，同时保存源代码与站点文件的结果，我很喜欢。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/17/5d2e8eea2cde391382.jpg&#34; alt=&#34;Select Source&#34; /&gt;&lt;/p&gt;

&lt;p&gt;稍等片刻，便能输入 &lt;code&gt;yourname.github.io&lt;/code&gt; 看到你的博客了。&lt;/p&gt;

&lt;h3 id=&#34;自定义域名&#34;&gt;自定义域名&lt;/h3&gt;

&lt;p&gt;当然还是和以前一样自己弄了个域名，并且发现现在不需要手动增加一个 CNAME 文件，可以直接在设置里填写域名便会自动生成，很方便，好评。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/17/5d2e8eea3db9973301.jpg&#34; alt=&#34;Custom domain&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接着只需要在域名服务商那里设置一下 DNS 解析，由于我这次没有继续选择 DNSPOD，而是直接用的 NameSilo 后台的解析，所以改用 A 解析，四个 ip 地址都是 GitHub 提供的，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/17/5d2e8eea4c02a44820.jpg&#34; alt=&#34;DNS Records&#34; /&gt;&lt;/p&gt;

&lt;p&gt;至此，基本就全部完成，其它都是一些小东西的改动，日后慢慢来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://hestation.com/about/</link>
      <pubDate>Mon, 15 Jul 2019 12:08:23 +0800</pubDate>
      
      <guid>https://hestation.com/about/</guid>
      <description>

&lt;h3 id=&#34;关于我&#34;&gt;关于我&lt;/h3&gt;

&lt;p&gt;待补充&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>多设备使用 Hexo 写博客的解决方案</title>
      <link>https://hestation.com/2019/hexo-multi-devices/</link>
      <pubDate>Sun, 16 Jun 2019 15:39:47 +0800</pubDate>
      
      <guid>https://hestation.com/2019/hexo-multi-devices/</guid>
      <description>

&lt;p&gt;最近弄了一台 XPS 13，但同时原来的 MacBook Pro也在使用，就涉及到两台设备需要同时使用 Hexo 编辑、上传 Blog 文件的问题，所以想到把源文件放到服务器上，以下解决方案的记录。&lt;/p&gt;

&lt;h2 id=&#34;了解-hexo-机制&#34;&gt;了解 Hexo 机制&lt;/h2&gt;

&lt;p&gt;首先，要搞清楚使用 Hexo 搭建博客的基本机制，本地 git clone 自 Hexo 的并非我们要部署的文件，而通过 &lt;code&gt;hexo d&lt;/code&gt; 上传部署到 GitHub 的其实是它编译之后的文件，基本就是一个纯静态的 html + css + js 页面，不包括源文件，实际体现在我们本地就是 &lt;code&gt;.deploy_git&lt;/code&gt; 这个文件夹里的。&lt;/p&gt;

&lt;p&gt;了解其机制之后就好办了，一般情况通过 GitHub 作为中转站有两种方式，一种是在你 name.github.io 基础上直接新建一个 hexo 分支，并将它设置为默认分支，这样每次先将源文件推到 hexo 默认分支上，再编译部署实际内容到 master 分支，从而实现一个仓库同时管理源文件与博客文件。&lt;/p&gt;

&lt;p&gt;不过我比较喜欢单独建一个私有仓库来存储这些内容，以下是我的步骤：&lt;/p&gt;

&lt;h2 id=&#34;新建仓库存储源文件&#34;&gt;新建仓库存储源文件&lt;/h2&gt;

&lt;p&gt;1、先定义原博客文件夹目录为 blog，blog 下新建一个 .gitignore，将一些不需要上传保存的内容忽略掉：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;.DS_Store
Thumbs.db
db.json
*.log
node_modules/
public/
.deploy*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、Github 新建一个用于保存源文件的仓库，这里设置为 blog_backup（不需要添加 README 文件，直接空白的），然后将本地与远程仓库关联，并推上去。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git init
git commit -m “first commit”
git remote add origin git@github.com:&amp;lt;github_name&amp;gt;/blog_backup.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、完成之后，可以检查下是否成功，是否一些主动忽略的文件夹没有上传上去，确认没有问题之后，再去其它机器操作。&lt;/p&gt;

&lt;h2 id=&#34;服务器操作&#34;&gt;服务器操作&lt;/h2&gt;

&lt;p&gt;解决了源文件上传同步问题，接下来就是 ssh 到服务器把文件 down 下载，然后安装好本地部署需要的环境，再编译上传即可，这里以 GCP 为例：&lt;/p&gt;

&lt;p&gt;1、直接在 &lt;code&gt;VM 实例&lt;/code&gt; 页面点击 SSH 连接，登陆到终端，然后搭建 git 环境&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装 Git&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install git
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;设置 Git 全局邮箱和用户名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config --global user.name &amp;quot;yourgithubname&amp;quot;
git config --global user.email &amp;quot;yourgithubemail&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;设置ssh&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;keyssh-keygen -t rsa -C &amp;quot;youremail&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;将 id_rsa 公钥粘贴到 Github&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;安装 Node.js&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;重启终端，然后通过 nvm 安装&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nvm install stable
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;全局安装 Hexo&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install -g hexo-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，本地环境已经安装完毕，接着下载源文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git@github.com:&amp;lt;github_name&amp;gt;/blog_backup.git
cd blog_backup
npm install
npm install hexo-deployer-git --save
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;注意-这里由于原有的-git-源文件仓库里的-themes-还包含了主题的-git-仓库-所以实际主题的东西没有被下载下来-需要手动再-clone-一次&#34;&gt;注意，这里由于原有的 Git 源文件仓库里的 themes 还包含了主题的 git 仓库，所以实际主题的东西没有被下载下来，需要手动再 clone 一次。&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd your-hexo-site
git clone https://github.com/iissnan/hexo-theme-next themes/next
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，新机器就与旧的环境保持一致了，每次做了任何修改，先把源文件 Git 上传一下，然后再通过 &lt;code&gt;hexo g -d&lt;/code&gt; 部署编译。&lt;/p&gt;

&lt;p&gt;而如果在另一个电脑上操作，就先 &lt;code&gt;git pull&lt;/code&gt; 一下，保证与线上内容一致。&lt;/p&gt;

&lt;h2 id=&#34;以上内容参考资料&#34;&gt;以上内容参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/21193762&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.zhihu.com/question/21193762&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hexo.io/docs/index.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://hexo.io/docs/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://theme-next.iissnan.com&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://theme-next.iissnan.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>如何注册并使用美区 Apple ID</title>
      <link>https://hestation.com/2018/reg-appleid/</link>
      <pubDate>Thu, 15 Nov 2018 12:30:03 +0800</pubDate>
      
      <guid>https://hestation.com/2018/reg-appleid/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;因为每个人的使用需求不同，比如 SS、SSR、V2 等都需要相对应的网络代理工具 App。但由于某些特殊原因，中国区 App Store 基本上下架了大部分的网络代理工具 App（例如用的比较多的小火箭 Shadowrocket 和圈 Quantumult 等等）。&lt;/p&gt;

&lt;p&gt;因为中国区无法下载到自己所需要使用的App，则大部分人都需要注册非中国区（如美区、港区等）的应用商店付费进行下载（出于尊重作者的角度出发，请尽量不要使用共享 Apple ID 账号下载软件，正版 App 其实也就几十块钱）。&lt;/p&gt;

&lt;p&gt;本文以注册美区 Apple ID 账号为例（其他地区账号同理），但关于美区 Apple ID 账号和绑定  PayPal 自行 Google 搜索相关教程，如需求较大后续我可以再出相关教程。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;美区 Apple ID 账户可绑定美区（只能美区，其他地区不行） Paypal 进行付款。&lt;/li&gt;
&lt;li&gt;港区 Apple ID 账户可注册 &lt;code&gt;Tap and Go&lt;/code&gt; 香港 MS 虚拟预付信用卡并绑定港区 Apple ID 账户进行付款（前提你要有港澳通行证）。具体操作可参考 BIGDONGDONG 的视频教学：&lt;a href=&#34;https://www.youtube.com/watch?v=97IzYP0zNqk&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;5分钟让你拥有一张 Mastercard 外币种卡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;日区 Apple ID 账户可直接绑定 JCB 信用卡进行付款。&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;注册美区-apple-id-账户&#34;&gt;注册美区 Apple ID 账户&lt;/h2&gt;

&lt;h3 id=&#34;登陆苹果账户官网&#34;&gt;登陆苹果账户官网&lt;/h3&gt;

&lt;p&gt;首先打开 &lt;a href=&#34;appleid.apple.com&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;appleid.apple.com&lt;/a&gt;，首次打开时首页展示图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/01/01/5c2b2dd95185d.jpg&#34; alt=&#34;创建 Apple ID&#34; /&gt;&lt;/p&gt;

&lt;p&gt;点击底部 &lt;code&gt;Create your Apple ID&lt;/code&gt; 进入注册账户界面，示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/01/01/5c2b2dd96cbc4.jpg&#34; alt=&#34;地区：美国&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;国家/地区&lt;/code&gt;一定要选择 &lt;code&gt;United States&lt;/code&gt;，也就是&lt;code&gt;美国&lt;/code&gt;，这点很重要，直接决定了你的账户是属于哪个&lt;code&gt;国家/地区&lt;/code&gt;（如果想注册香港地区的账号，请选择 &lt;code&gt;HONG KONG&lt;/code&gt;，其他国家/地区同理）。&lt;/p&gt;

&lt;p&gt;美区Apple ID建议使用&lt;code&gt;谷歌邮箱&lt;/code&gt;注册（为了好过玄学美区 PayPal 绑定）。注册内容全部填写完毕后，拉到最下面点击继续，示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/01/01/5c2b2dd965152.jpg&#34; alt=&#34;填写完所有信息后继续&#34; /&gt;&lt;/p&gt;

&lt;p&gt;点击继续按钮后，苹果会让你验证你的电子邮件，示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/01/01/5c2b2dd9755a5.jpg&#34; alt=&#34;邮箱验证&#34; /&gt;&lt;/p&gt;

&lt;p&gt;验证完毕后，会进入你的&lt;code&gt;账户信息页面&lt;/code&gt;，如果&lt;code&gt;国家/地区&lt;/code&gt;显示为&lt;code&gt;美国&lt;/code&gt;，则注册成功，示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/01/01/5c2b2dd98cb07.jpg&#34; alt=&#34;注册成功示意图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，注册好新账户后，美区 Apple ID 还暂不可用，需要在手机上登陆 App Store 来激活新注册的美区账户，才可使用。&lt;/p&gt;

&lt;p&gt;在用新美区账户登陆 App Store 之前，请确保你的手机打开了美国节点的&lt;code&gt;全局翻墙&lt;/code&gt;！这点很重要，否则无法完成激活！（除非你有付款方式）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;PS：如果是激活港区 Apple ID，请使用香港节点全局翻墙，其他地区同理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;激活美区账户&#34;&gt;激活美区账户&lt;/h3&gt;

&lt;p&gt;打开 &lt;code&gt;App Store&lt;/code&gt;，并点击&lt;code&gt;右上角头像&lt;/code&gt;（本教程使用的设备系统为 iOS 12，比较老的系统如果右上角没有头像，请直接拉到 App Store 首页最下面，点击你的账户并退出），示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/01/01/5c2b2dda2653a.png&#34; alt=&#34;App Store 首页&#34; /&gt;&lt;/p&gt;

&lt;p&gt;退出现有账户，输入新注册的美区 Apple ID 账户及密码，并点击 &lt;code&gt;Sign In&lt;/code&gt; 登陆，示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/01/01/5c2b2dd985df9.jpg&#34; alt=&#34;登陆美区 Apple ID&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因为是第一次登陆，会提示你账户从未使用过，需要进行检查（其实也就是让你填写付款信息和确认国家），请直接点击 &lt;code&gt;Review&lt;/code&gt; 并进入下一步，示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/01/01/5c2b2dd97d197.jpg&#34; alt=&#34;检查账户信息&#34; /&gt;&lt;/p&gt;

&lt;p&gt;请确认你的&lt;code&gt;国家/地区&lt;/code&gt;是在 &lt;code&gt;United States&lt;/code&gt; ，然后点击下一行按钮使其变成绿色，最后点击右上角 &lt;code&gt;Next&lt;/code&gt;，示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/01/01/5c2b2dd993e8f.jpg&#34; alt=&#34;示意图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里有一点需要注意的是，如果你没有开启美国节点的全局模式，则付款方式（PAYMENT METHOD）这里不会出现 &lt;code&gt;None&lt;/code&gt; 这个选项，并且只有 &lt;code&gt;Credit/Debit Card&lt;/code&gt; 以及 &lt;code&gt;PayPal&lt;/code&gt; 这2个付款方式选项。&lt;/p&gt;

&lt;p&gt;如果发现付款方式中没有 &lt;code&gt;None&lt;/code&gt; 这个选项，请确认你的节点是否为美国节点的&lt;code&gt;全局模式&lt;/code&gt;，如果是美国节点并且开启了全局，则说明此节点不可用，请切换节点！&lt;/p&gt;

&lt;p&gt;下面的地址及电话号码请直接去谷歌地图随便点击一个美国的地理位置然后输入信息即可，或直接 &lt;a href=&#34;https://www.fakeaddressgenerator.com/World/us_address_generator&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这个网站&lt;/a&gt; 生成一个地址（建议填写&lt;code&gt;美国免税州地址&lt;/code&gt;，如果是用给出的生成地址网站可以自行筛选指定免税州信息，具体问题请谷歌）。&lt;/p&gt;

&lt;p&gt;全部信息填写完成后，点击右上角 &lt;code&gt;Next&lt;/code&gt; 进入下一步，示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/01/01/5c2b2dd98993e.jpg&#34; alt=&#34;付款方式选择 None&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这时苹果会提示你，账户可继续使用，至此，美区 Apple ID 注册才全部完成，点击 &lt;code&gt;Continue&lt;/code&gt; 完成，示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/01/01/5c2b2e5202881.jpg&#34; alt=&#34;完成&#34; /&gt;&lt;/p&gt;

&lt;p&gt;之后，就可以在 App Store 里搜索 &lt;code&gt;网络代理工具App&lt;/code&gt;，如 &lt;code&gt;Quantumult&lt;/code&gt;，示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/01/01/5c2b2e52a5fb5.png&#34; alt=&#34;Quantumult&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;注意事项&#34;&gt;注意事项&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;以下两部分内容来源参考自热心网友 @taresky，原文地址：&lt;a href=&#34;https://taresky.com/post/Apple-ID-US&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;美区 Apple ID 使用指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;如何使用美区-apple-id-购物&#34;&gt;如何使用美区 Apple ID 购物&lt;/h3&gt;

&lt;p&gt;由于美区 Apple ID &lt;code&gt;仅支持绑定美国发卡行的信用卡/借记卡&lt;/code&gt;，故在支付方式上相对较困难，以下是几种常规的解决方式：&lt;/p&gt;

&lt;p&gt;1、直接在 &lt;code&gt;苹果美国官网&lt;/code&gt; 购买 &lt;code&gt;iTunes Gift Card&lt;/code&gt; 礼品卡，充值到账户余额，此方式支持国内发卡行的双币种卡或全币种卡，若支付失败可能是发卡行的问题，换卡重试。谨慎在淘宝购买任何 &lt;code&gt;App 兑换码&lt;/code&gt; 或 &lt;code&gt;iTunes Gift Card&lt;/code&gt;，很大部分是黑卡（被盗刷的信用卡），有封号危险。&lt;/p&gt;

&lt;p&gt;2、绑定美区支持的信用卡或Paypal，有如下几种方式推荐：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果刚好要去美国当地旅游，可顺便办理美国的信用卡或储蓄卡，这种方法最稳定。&lt;/li&gt;
&lt;li&gt;绑定美区 PayPal（方便，但有一定几率被风控导致不能支付）&lt;/li&gt;
&lt;li&gt;购买 &lt;code&gt;Visa Gift Card&lt;/code&gt;，这是 Visa 的储值卡，类似于香港拍住赏这种，余额用完后无法充值，在美国当地（或淘宝）可购买，&lt;a href=&#34;https://www.simon.com/giftcard/card_balance.aspx&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Simon Gift Card&lt;/a&gt; 是其中一种，也可自行选择其他的，但建议每次购买最小面额，防止意外损失。&lt;/li&gt;
&lt;li&gt;在某些国内银行做见证开户，如美国国泰银行账户可在浙江民泰银行开户（这种只是网传，本人并没有亲测）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;重点注意的&#34;&gt;重点注意的&lt;/h3&gt;

&lt;p&gt;使用美区 Apple ID，本质上其实是违反苹果的用户协议的行为，所以请尽量减少触发风控的一些操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IP频繁变动&lt;/li&gt;
&lt;li&gt;Apple ID在多台设备登录（可能被识别为共享软件行为，即盗版）&lt;/li&gt;
&lt;li&gt;消费频繁且金额过高，IP有异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;群里看到部分人最近绑定或通过美区 PayPal 支付时遇到“很抱歉，无法设置您对 iTunes and App Store 的预核准付款”的提示，建议先将支付方式修改为 &lt;code&gt;None&lt;/code&gt;，然后将 Apple ID 和美区 Paypal 的付款地址修改为相同的免税州地址，接着再次尝试绑定，若依然有问题，大概率是触发了苹果的风控，如果英文足够好，可直接致电美区苹果客服要求帮你处理；若英文不够好，建议等待两三天后尝试是否可以使用；若还不行，建议换用其它支付方式。&lt;/p&gt;

&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;

&lt;p&gt;新手按照上述教程可 100% 完成所有地区账户的 Apple ID 注册。&lt;/p&gt;

&lt;p&gt;需要注意的是，App Store 是根据登陆账户的地区来自动适配语言的。哪怕你手机系统是中文，但如果是美区账户，则 App Store 就是英文（我了解过来是这样），具体可以自己摸索。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>华硕 RT-AC86U 刷梅林改版系统</title>
      <link>https://hestation.com/2018/merlin/</link>
      <pubDate>Thu, 01 Nov 2018 11:18:03 +0800</pubDate>
      
      <guid>https://hestation.com/2018/merlin/</guid>
      <description>

&lt;p&gt;前几天刚把 K2P 换成 86U，以下是 86U 刷梅林系统的步骤，非常简单：&lt;/p&gt;

&lt;h2 id=&#34;刷机前的准备&#34;&gt;刷机前的准备&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;EXT 格式的 1G 以上 U盘一个，如果不知道怎么格式化，可以查看此文章附录。&lt;/li&gt;
&lt;li&gt;改版梅林安装包，下载地址为：&lt;a href=&#34;https://1drv.ms/u/s!ArS0nJ_RMzVYgtwvUNgsl7Q1Z9W75Q&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;，或直接到Coolshare论坛下载：&lt;a href=&#34;http://koolshare.cn/thread-127878-1-1.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;科学上网工具离线安装包，下载地址为&lt;a href=&#34;https://1drv.ms/u/s!ArS0nJ_RMzVYgtwuoBmaqxYUM2UrxA&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;，或直接到&lt;a href=&#34;https://github.com/hq450/fancyss&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;上找到与你机器相匹配的&lt;/li&gt;
&lt;li&gt;一根网线，用于连接电脑与路由器&lt;/li&gt;
&lt;li&gt;一杯茶，用于等待的时候喝哈哈哈&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;正式开刷&#34;&gt;正式开刷&lt;/h2&gt;

&lt;h3 id=&#34;系统初始化&#34;&gt;系统初始化&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;拿到机器后，打开机器背后开关键，然后连上电源，开机。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;找到一根网线，一头接自己的电脑，另一头接路由器的LAN口。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在浏览器地址栏中输入&lt;a href=&#34;http://router.asus.com&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;router.asus.com&lt;/a&gt;进入管理后台。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;依次设置自己的PPPoE、无线WIFI、管理后台账号，设置完之后会进入到官方原版的后台界面。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;刷改版梅林固件&#34;&gt;刷改版梅林固件&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在后台管理界面中找到&lt;code&gt;高级设置&lt;/code&gt;-&lt;code&gt;系统管理&lt;/code&gt;-&lt;code&gt;固件升级&lt;/code&gt;，选择刚才将已准备好的梅林固件（格式为.w），然后点击上传，等待两三分钟即可，当重启后重新进入后台时有一个 &lt;code&gt;Powered by Asuswrt-Merlin &amp;amp; Coolshare&lt;/code&gt; 代表成功。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;双清路由器。进入&lt;code&gt;高级设置&lt;/code&gt;-&lt;code&gt;系统设置&lt;/code&gt;，找到&lt;code&gt;Presistent JFFS2 parttition&lt;/code&gt;，将&lt;code&gt;Format JFFS partition at next boot&lt;/code&gt;和&lt;code&gt;Enable JFFS custom scripts and configs&lt;/code&gt;两项都设置为是，并点击&lt;code&gt;应用本页面设置&lt;/code&gt;按钮，然后重启路由器即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;安装科学上网工具&#34;&gt;安装科学上网工具&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;由于梅林已经取消软件中心的科学上网工具在线安装，所以可采取离线安装的方式。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从&lt;a href=&#34;https://1drv.ms/u/s!ArS0nJ_RMzVYgtwuoBmaqxYUM2UrxA&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;上下载离线安装包，打开软件中心，先点击更新将软件中心升级到最新版本，然后点击&lt;code&gt;离线安装&lt;/code&gt;，上传刚才下载的安装包，注意格式需要为&lt;code&gt;.tar.gz&lt;/code&gt;，如果不对，手动将其补全后再上传。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;等待安装成功后，再打开科学上网，再配置自己的节点即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;挂载虚拟内存&#34;&gt;挂载虚拟内存&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将已准备好的EXT格式U盘插入路由器背部接口（2.0或3.0都可以）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打开软件中心，将&lt;code&gt;虚拟内存&lt;/code&gt;这个软件安装上&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打开该软件，选择这个磁盘，我这里叫做&lt;code&gt;sda&lt;/code&gt;，选择虚拟内存大小为&lt;code&gt;512M&lt;/code&gt;或&lt;code&gt;1G&lt;/code&gt;，然后点创建虚拟内存，等待一段时间即可。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;再次打开软件中心-虚拟内存，确保状态显示为&lt;code&gt;在/mnt/sda下找到swapfile，且已成功挂载！&lt;/code&gt;，表明已挂载成功。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;附录-u盘格式化为ext格式&#34;&gt;附录：U盘格式化为EXT格式&lt;/h2&gt;

&lt;p&gt;准备好一个1G以上的U盘（随便的都行，利用率不高），并格式化为EXT2,3,4任意的格式，我这边用的是EXT3。&lt;/p&gt;

&lt;h3 id=&#34;windows系统&#34;&gt;Windows系统&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果没有Linux基础，可使用软件进行操作，可参考百度经验：&lt;a href=&#34;https://jingyan.baidu.com/article/fea4511a142846f7bb912522.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;如何在windows下把硬盘格式化成EXT3格式？&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果有一定Linux基础，可使用SSH连接到路由器通过路由器进行操作，具体步骤如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开路由器后台&lt;code&gt;高级设置&lt;/code&gt;-&lt;code&gt;系统设置&lt;/code&gt;，找到&lt;code&gt;服务&lt;/code&gt;中的&lt;code&gt;启用SSH&lt;/code&gt;，选择打开&lt;code&gt;LAN+WAN&lt;/code&gt;，然后保存设置。&lt;/li&gt;
&lt;li&gt;下载一个叫PuTTY的软件，hostname填&lt;code&gt;192.168.50.1&lt;/code&gt;（路由器后台地址，可能不一样，自己查看下） 然后选择&lt;code&gt;SSH&lt;/code&gt;。port端口号为&lt;code&gt;22&lt;/code&gt;，然后点open。&lt;/li&gt;
&lt;li&gt;用自己前面设置的路由器账号密码登录即可，然后出现命令行界面。&lt;/li&gt;
&lt;li&gt;在U盘插入路由器后面的情况下，依次输入以下命令（两横杠后的是解释说明，不用输入），然后等待显示完成即可。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;df -h // 找到你的盘符,如：sda1
umount /dev/sda1 // 解除进程的占用
/bin/mkntfs /dev/sda1 // 格式化硬盘为ntfs格式
mkfs.ext4 -T largefile /dev/sda1 // 格式化硬盘为ext4格式
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;macos系统&#34;&gt;macOS系统&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;确保已经安装了Mac下的包管理软件Homebrew，如果没有，可以用以下命令安装&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;安装 e2fsprogs&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install e2fsprogs
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;插上U盘，执行以下命令在执行结果中找到U盘盘符，我这里是&lt;code&gt;/dev/disk2s1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;diskutil list
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;卸载U盘并将其格式化为 &lt;code&gt;ext2/3/4&lt;/code&gt;格式，这里以ext3为例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;diskutil unmountdisk /dev/disk2s1
sudo $(brew --prefix e2fsprogs)/sbin/mkfs.ext3 /dev/disk2s1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;中间可能会有确认提示，按提示操作即可。格式化完成就能直接拔掉U盘了。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>《野火集》语录-第30页</title>
      <link>https://hestation.com/2017/yehuoji-30/</link>
      <pubDate>Sun, 16 Jul 2017 16:10:21 +0800</pubDate>
      
      <guid>https://hestation.com/2017/yehuoji-30/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;一个不公的体制压着人民，能够长久地压着，因为它有一个社会哲学的托词：逆来顺受、明哲保身的社会哲学。看穿了体制不公的人知道事不可为而转向冷漠；不曾看穿的人则早被教育了忍耐是美德、忍受是义务。 但是闷啊，这是一个有冤无处申的社会。&lt;/p&gt;

&lt;p align=&#34;right&#34;&gt;《野火集》–龙应台&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>龙应台《 野火集》摘录</title>
      <link>https://hestation.com/2017/yehuoji/</link>
      <pubDate>Sun, 16 Jul 2017 16:08:12 +0800</pubDate>
      
      <guid>https://hestation.com/2017/yehuoji/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;我们的上一代，受战乱和贫穷之苦，期望我们这一代温饱安定。&lt;/p&gt;

&lt;p&gt;我们这一代温饱安定了，但是受威权统治之苦，&lt;/p&gt;

&lt;p&gt;期望下一代在没有恐惧、没有控制的自由环境中成长。&lt;/p&gt;

&lt;p align=&#34;right&#34;&gt;《野火集》–龙应台&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>第一篇文章用于测试</title>
      <link>https://hestation.com/2017/my-first-post/</link>
      <pubDate>Fri, 14 Jul 2017 18:31:53 +0800</pubDate>
      
      <guid>https://hestation.com/2017/my-first-post/</guid>
      <description>

&lt;h2 id=&#34;welcome-to-github-pages&#34;&gt;Welcome to GitHub Pages&lt;/h2&gt;

&lt;p&gt;You can use the &lt;a href=&#34;https://github.com/jolsonhy/jolsonhy.github.io/edit/master/README.md&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;editor on GitHub&lt;/a&gt; to maintain and preview the content for your website in Markdown files.&lt;/p&gt;

&lt;p&gt;Whenever you commit to this repository, GitHub Pages will run &lt;a href=&#34;https://jekyllrb.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Jekyll&lt;/a&gt; to rebuild the pages in your site, from the content in your Markdown files.&lt;/p&gt;

&lt;h3 id=&#34;markdown&#34;&gt;Markdown&lt;/h3&gt;

&lt;p&gt;Markdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Syntax highlighted code block

# Header 1
## Header 2
### Header 3

- Bulleted
- List

1. Numbered
2. List

**Bold** and _Italic_ and `Code` text

[Link](url) and ![Image](src)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more details see &lt;a href=&#34;https://guides.github.com/features/mastering-markdown/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;GitHub Flavored Markdown&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;jekyll-themes&#34;&gt;Jekyll Themes&lt;/h3&gt;

&lt;p&gt;Your Pages site will use the layout and styles from the Jekyll theme you have selected in your &lt;a href=&#34;https://github.com/jolsonhy/jolsonhy.github.io/settings&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;repository settings&lt;/a&gt;. The name of this theme is saved in the Jekyll &lt;code&gt;_config.yml&lt;/code&gt; configuration file.&lt;/p&gt;

&lt;h3 id=&#34;support-or-contact&#34;&gt;Support or Contact&lt;/h3&gt;

&lt;p&gt;Having trouble with Pages? Check out our &lt;a href=&#34;https://help.github.com/categories/github-pages-basics/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;documentation&lt;/a&gt; or &lt;a href=&#34;https://github.com/contact&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;contact support&lt;/a&gt; and we’ll help you sort it out.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React学习笔记</title>
      <link>https://hestation.com/2016/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 11 Jun 2016 14:23:41 +0000</pubDate>
      
      <guid>https://hestation.com/2016/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;前段时间看了一下React和react-router的文档，这几天用它们在做一个实时投票的Web App，这篇文章记录里面遇到的坑及其解决方法。&lt;/p&gt;

&lt;h2 id=&#34;获取真实dom节点的引用&#34;&gt;获取真实DOM节点的引用&lt;/h2&gt;

&lt;p&gt;添加ref属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;ref={(ref) =&amp;gt; this.name = ref}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Demo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export default class Join extends React.Component {
    constructor(props) {
        super(props);

        this.handleSubmit = (e) =&amp;gt; {
            e.preventDefault();
            let memberName = this.name.value;
            console.log(&amp;quot;TODO: Join member &amp;quot; + memberName);
        }
    }
    render() {
        return (
            &amp;lt;form onSubmit={this.handleSubmit}&amp;gt;
                &amp;lt;label&amp;gt;Full Name&amp;lt;/label&amp;gt;
                &amp;lt;input
                    ref={(ref) =&amp;gt; this.name = ref}
                    className=&amp;quot;form-control&amp;quot;
                    placeholder=&amp;quot;Enter your full name...&amp;quot;
                    required /&amp;gt;
                &amp;lt;button className=&amp;quot;btn btn-primary&amp;quot;&amp;gt;Join&amp;lt;/button&amp;gt;
            &amp;lt;/form&amp;gt;
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用react-router时父组件向子组件传递props&#34;&gt;使用React-Router时父组件向子组件传递props&lt;/h2&gt;

&lt;p&gt;原本渲染所有路由组件的写法为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{this.props.children}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现可表示为：
在父组件的return的最底部添加：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{React.cloneElement(this.props.children, {propsName: this.props.name})}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;react-router&#34;&gt;React-Router&lt;/h2&gt;

&lt;h3 id=&#34;默认路由&#34;&gt;默认路由&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;IndexRoute component={Audience} /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;重定向&#34;&gt;重定向&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;Redirect from=&amp;quot;audience&amp;quot; to=&amp;quot;/&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Demo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;ReactDOM.render((
    &amp;lt;Router history={hashHistory}&amp;gt;
        &amp;lt;Route path=&amp;quot;/&amp;quot; component={App}&amp;gt;
            &amp;lt;IndexRoute component={Audience} /&amp;gt;
            &amp;lt;Route path=&amp;quot;board&amp;quot; component={Board} /&amp;gt;
            &amp;lt;Route path=&amp;quot;speaker&amp;quot; component={Speaker} /&amp;gt;
            &amp;lt;Redirect from=&amp;quot;audience&amp;quot; to=&amp;quot;/&amp;quot; /&amp;gt;
            &amp;lt;Route path=&amp;quot;*&amp;quot; component={NotFound} /&amp;gt;
        &amp;lt;/Route&amp;gt;
    &amp;lt;/Router&amp;gt;
), document.getElementById(&#39;container&#39;));
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Webpack--令人困惑的地方</title>
      <link>https://hestation.com/2016/webpack-%E4%BB%A4%E4%BA%BA%E5%9B%B0%E6%83%91%E7%9A%84%E5%9C%B0%E6%96%B9/</link>
      <pubDate>Mon, 16 May 2016 09:15:00 +0000</pubDate>
      
      <guid>https://hestation.com/2016/webpack-%E4%BB%A4%E4%BA%BA%E5%9B%B0%E6%83%91%E7%9A%84%E5%9C%B0%E6%96%B9/</guid>
      <description>

&lt;h2 id=&#34;原文&#34;&gt;原文&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@rajaraodv/webpack-the-confusing-parts-58712f8fcad9#.jaqo97f72&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Webpack—The Confusing Parts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chemdemo/chemdemo.github.io/issues/13&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;【翻译】Webpack——令人困惑的地方&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Webpack是目前基于React和Redux开发的应用的主要打包工具。我想使用Angular 2或其他框架开发的应用也有很多在使用Webpack。&lt;/p&gt;

&lt;p&gt;当我第一次看到Webpack的配置文件时，它看起来非常的陌生，我非常的疑惑。经过一段时间的尝试之后我认为这是因为Webpack只是使用了比较特别的语法和引入了新的原理，因此会让使用者感到疑惑。这些也是导致Webpack不被人熟悉的原因。&lt;/p&gt;

&lt;p&gt;因为刚开始使用Webpack很让人疑惑，我觉得有必要写几篇介绍Webpack的功能和特性的文章以帮助初学者快速理解。此文是最开始的一篇。&lt;/p&gt;

&lt;h2 id=&#34;webpack的核心原理&#34;&gt;Webpack的核心原理&lt;/h2&gt;

&lt;p&gt;Webpack的两个最核心的原理分别是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一切皆模块
正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以&lt;code&gt;require(&#39;myJSfile.js&#39;)&lt;/code&gt;亦可以&lt;code&gt;require(&#39;myCSSfile.css&#39;)&lt;/code&gt;。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;按需加载
传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的&lt;code&gt;bundle.js&lt;/code&gt;文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;好了，下面来看看那些令人困惑的部分吧。&lt;/p&gt;

&lt;h3 id=&#34;1-开发模式和生产模式&#34;&gt;1.开发模式和生产模式&lt;/h3&gt;

&lt;p&gt;首先要知道的是Webpack有许许多多的特性，一些是”开发模式“下才有的，一些是”生产模式“下才有的，还有一些是两种模式下都有的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/769d362aaca4e1bea0c9f3abd1fd67f656c649d1/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a574341644d69303449464557646e674b38626b4663772e706e67&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;通常使用到Webpack如此多特性的项目都会有两个比较大的Webpack配置文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了生成bundles文件你可能在&lt;code&gt;package.json&lt;/code&gt;文件加入如下的scripts项：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;quot;scripts&amp;quot;: {
  // 运行npm run build 来编译生成生产模式下的bundles
  &amp;quot;build&amp;quot;: &amp;quot;webpack --config webpack.config.prod.js&amp;quot;,
  // 运行npm run dev来生成开发模式下的bundles以及启动本地server
  &amp;quot;dev&amp;quot;: &amp;quot;webpack-dev-server&amp;quot;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-webpack-cli-和webpack-dev-server&#34;&gt;2.webpack CLI 和webpack-dev-server&lt;/h3&gt;

&lt;p&gt;值得注意的是，Webpack作为模块打包工具，提供两种用户交互接口：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Webpack CLI tool：默认的交互方式（已随Webpack本身安装到本地）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;webpack-dev-server：一个Node.js服务器（需要开发者从npm自行安装）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;webpack-cli-有利于生产模式下打包&#34;&gt;Webpack CLI（有利于生产模式下打包）&lt;/h4&gt;

&lt;p&gt;这种方式可以从命令行获取参数也可以从配置文件（默认叫webpack.config.js）获取，将获取到的参数传入Webpack来打包。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当然你也可以从命令行（CLI）开始学习Webpack，以后你可能主要在生产模式下使用到它。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;方式1: 
// 全局模式安装webpack
npm install webpack --g
// 在终端输入
$ webpack // &amp;lt;--使用webpack.config.js生成bundle

方式 2 :
// 费全局模式安装webpack然后添加到package.json依赖里边
npm install webpack --save
// 添加build命令到package.json的scripts配置项
&amp;quot;scripts&amp;quot;: {
 &amp;quot;build&amp;quot;: &amp;quot;webpack --config webpack.config.prod.js -p&amp;quot;,
 ...
 }
// 用法：
&amp;quot;npm run build&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;webpack-dev-server-有利于在开发模式下编译&#34;&gt;webpack-dev-server（有利于在开发模式下编译）&lt;/h4&gt;

&lt;p&gt;这是一个基于Express.js框架开发的web server，默认监听8080端口。server内部调用Webpack，这样做的好处是提供了额外的功能如热更新“Live Reload”以及热替换“Hot Module Replacement”（即HMR）。&lt;/p&gt;

&lt;p&gt;用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;方式 1:
// 全局安装
npm install webpack-dev-server --save
// 终端输入
$ webpack-dev-server --inline --hot

用法 2:
// 添加到package.json scripts
&amp;quot;scripts&amp;quot;: {
 &amp;quot;start&amp;quot;: &amp;quot;webpack-dev-server --inline --hot&amp;quot;,
 ...
 }
// 运行： 
$ npm start

// 浏览器预览：
http://localhost:8080
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;webpack-vs-webpack-dev-server选项&#34;&gt;Webpack VS Webpack-dev-server选项&lt;/h4&gt;

&lt;p&gt;注意像inline和hot这些选项是Webpack-dev-server特有的，而另外的如hide-modules则是CLI模式特有的选项。&lt;/p&gt;

&lt;h4 id=&#34;webpack-dev-server-cli选项和配置项&#34;&gt;webpack-dev-server CLI选项和配置项&lt;/h4&gt;

&lt;p&gt;另外值得注意的是你可以通过以下两种方式向webpack-dev-server传入参数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过webpack.config.js文件的&amp;rdquo;devServer&amp;rdquo;对象&lt;/li&gt;
&lt;li&gt;通过CLI选项&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;// 通过CLI传参
webpack-dev-server --hot --inline
// 通过webpack.config.js传参
devServer: {
  inline: true,
  hot:true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;我发现有时devServer配置项（hot: true 和inline: true）不生效，我更偏向使用如下的方式向CLI传递参数：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;// package.json
{
    &amp;quot;scripts&amp;quot;: &amp;quot;webpack-dev-server --hot --inline&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：确定你没有同时传入hot:true和-hot&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;webpack-dev-server的-hot-和-inline-选项&#34;&gt;webpack-dev-server的“hot” 和 “inline”选项&lt;/h4&gt;

&lt;p&gt;“inline”选项会为入口页面添加“热加载”功能，“hot”选项则开启“热替换（Hot Module Reloading）”，即尝试重新加载组件改变的部分（而不是重新加载整个页面）。如果两个参数都传入，当资源改变时，webpack-dev-server将会先尝试HRM（即热替换），如果失败则重新加载整个入口页面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;// 当资源发生改变，以下三种方式都会生成新的bundle，但是又有区别：

// 1. 不会刷新浏览器
$ webpack-dev-server
//2. 刷新浏览器
$ webpack-dev-server --inline
//3. 重新加载改变的部分，HRM失败则刷新页面
$ webpack-dev-server  --inline --hot
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;entry-值分别是字符串-数组和对象的情况&#34;&gt;“entry”：值分别是字符串、数组和对象的情况&lt;/h2&gt;

&lt;p&gt;Enter配置项告诉Webpack应用的根模块或起始点在哪里，它的值可以是字符串、数组或对象。这看起来可能令人困惑，因为不同类型的值有着不同的目的。&lt;/p&gt;

&lt;p&gt;像绝大多数app一样，倘若你的应用只有一个单一的入口，enter项的值你可以使用任意类型，最终输出的结果都是一样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/94d5882d5d4c236cf6a550f604358193fd9a8ec4/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a4f6e58706676347a6a4c2d357a4f324861366d5844772e706e67&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;enter-数组类型&#34;&gt;enter：数组类型&lt;/h3&gt;

&lt;p&gt;但是，如果你想添加多个彼此不互相依赖的文件，你可以使用数组格式的值。&lt;/p&gt;

&lt;p&gt;例如，你可能在html文件里引用了“googleAnalytics.js”文件，可以告诉Webpack将其加到bundle.js的最后。
&lt;img src=&#34;https://camo.githubusercontent.com/cbc2ac1d6c1059654ddc9ab03d0fd5e3369c6d9a/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a794c566453336f4e34586f384b496e6f5449666930412e706e67&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;enter-对象&#34;&gt;enter：对象&lt;/h3&gt;

&lt;p&gt;现在，假设你的应用是多页面的（multi-page application）而不是SPA，有多个html文件（index.html和profile.html）。然后你通过一个对象告诉Webpack为每一个html生成一个bundle文件。&lt;/p&gt;

&lt;p&gt;以下的配置将会生成两个js文件：indexEntry.js和profileEntry.js分别会在index.html和profile.html中被引用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/2ee6bc5c88b5cdb9452f3389a6e2e7060402b3f0/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a7842353152524334696b36424250326c4a39304975772e706e67&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;//profile.html
&amp;lt;script src=”dist/profileEntry.js”&amp;gt;&amp;lt;/script&amp;gt;
//index.html
&amp;lt;script src=”dist/indexEntry.js”&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：文件名取自“entry”对象的键名。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;enter-混合类型&#34;&gt;enter：混合类型&lt;/h3&gt;

&lt;p&gt;你也可以在enter对象里使用数组类型，例如下面的配置将会生成3个文件：vender.js（包含三个文件），index.js和profile.js文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/7cb0c356dff08cfca479e68a5165a381c70aa613/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a797a373651593166567a42474b4a2d365836456c65672e706e67&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;output-path-项和-publicpath-项&#34;&gt;output：“path”项和“publicPath”项&lt;/h2&gt;

&lt;p&gt;output项告诉webpack怎样存储输出结果以及存储到哪里。output的两个配置项“path”和“publicPath”可能会造成困惑。&lt;/p&gt;

&lt;p&gt;“path”仅仅告诉Webpack结果存储在哪里，然而“publicPath”项则被许多Webpack的插件用于在生产模式下更新内嵌到css、html文件里的url值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/4802b6cfbcdfbb7cada7121ae14ba616c716edab/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a36335a7461346d62435f336f343451647963724437512e706e67&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;例如，在localhost（译者注：即本地开发模式）里的css文件中边你可能用“./test.png”这样的url来加载图片，但是在生产模式下“test.png”文件可能会定位到CDN上并且你的Node.js服务器可能是运行在HeroKu上边的。这就意味着在生产环境你必须手动更新所有文件里的url为CDN的路径。&lt;/p&gt;

&lt;p&gt;然而你也可以使用Webpack的“publicPath”选项和一些插件来在生产模式下编译输出文件时自动更新这些url。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/3cc10014e06c18fda61c2f5fa6b31f5275d4cafd/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a614f4d355a4638616c574c723442433043665a6530772e706e67&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;// 开发环境：Server和图片都是在localhost（域名）下
.image { 
background-image: url(&#39;./test.png&#39;);
}
// 生产环境：Server部署下HeroKu但是图片在CDN上
.image { 
background-image: url(&#39;https://someCDN/test.png&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;模块加载和链式模块加载&#34;&gt;模块加载和链式模块加载&lt;/h2&gt;

&lt;p&gt;模块加载器是可自由添加的Node模块，用于将不同类型的文件“load”或“import”并转换成浏览器可以识别的类型，如js、Stylesheet等。更高级的模块加载器甚至可以支持使用ES6里边的“require”或“import”引入模块。&lt;/p&gt;

&lt;p&gt;例如，你可以使用&lt;code&gt;babel-loader&lt;/code&gt;来将使用ES6语法写成的文件转换成ES5：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module: {
 loaders: [{
  test: /\.js$/, // 匹配.js文件，如果通过则使用下面的loader
  exclude: /node_modules/, // 排除node_modules文件夹
  loader: &#39;babel&#39; // 使用babel（babel-loader的简写）作为loader
 }]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;链式-管道式-的加载器-从右往左执行&#34;&gt;链式（管道式）的加载器（从右往左执行）&lt;/h3&gt;

&lt;p&gt;多个loader可以用在同一个文件上并且被链式调用。链式调用时从右到左执行且loader之间用“!”来分割。&lt;/p&gt;

&lt;p&gt;例如，假设我们有一个名为“myCssFile.css”的css文件，然后我们想将它的内容使用style标签内联到最终输出的html里边。我们可以使用css-loader和style-loader两个loader来达到目的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module: {
 loaders: [{
  test: /\.css$/,
  loader: &#39;style!css&#39; //(short for style-loader!css-loader)
 }]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里展示它是如何工作的：
&lt;img src=&#34;https://camo.githubusercontent.com/9c306d1bcc8f5fc732f772afd6101dcc88309eba/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a6e657339694c6d736b6d734438467034456b33752d412e706e67&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Webpack在模块颞部搜索在css的依赖项，即Webpack检查js文件是否有“require(&amp;lsquo;myCssFile.css&amp;rsquo;)”的引用，如果它发现有css的依赖，Webpack将css文件交给“css-loader”去处理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;css-loader加载所有的css文件以及css自身的依赖（如，@import 其他css）到JSON对象里，Webpack然后将处理结果传给“style-loader”&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;style-loader接受JSON值然后添加一个style标签并将其内嵌到html文件里&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;loader自身可以配置&#34;&gt;loader自身可以配置&lt;/h2&gt;

&lt;p&gt;模块加载器（loader）自身可以根据传入不同的参数进行配置。&lt;/p&gt;

&lt;p&gt;在下面的例子中，我们可以配置url-loader来将小于1024字节的图片使用DataUrl替换而大于1024字节的图片使用url，我们可以用如下两种方式通过传入“limit“参数来实现这一目的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/df52305c7926e1071636fa6ad8e60a6da91df9cc/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a2d71566463413345384a536474737a784871664964412e706e67&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;babelrc-文件&#34;&gt;babelrc 文件&lt;/h2&gt;

&lt;p&gt;babal-loader使用”presets“配置项来标识如何将ES6语法转成ES5以及如何转换React的JSX成js文件。我们可以用如下的方式使用”query“参数传入配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module: {
  loaders: [
    {
      test: /\.jsx?$/,
      exclude: /(node_modules|bower_components)/,
      loader: &#39;babel&#39;,
      query: {
        presets: [&#39;react&#39;, &#39;es2015&#39;]
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而在很多项目里babel的配置可能比较大，因此你可以把babel-loader的配置项单独保存在一个名为”.babelrc“的文件中，在执行时babel-loader将会自动加载.babelrc文件。&lt;/p&gt;

&lt;p&gt;所以在很多例子里，你可能会看到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//webpack.config.js 
module: {
  loaders: [
    {
      test: /\.jsx?$/,
      exclude: /(node_modules|bower_components)/,
      loader: &#39;babel&#39;
    }
  ]
}

//.bablerc
{
 presets: [&#39;react&#39;, &#39;es2015&#39;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;插件&#34;&gt;插件&lt;/h2&gt;

&lt;p&gt;插件一般都是用于输出bundle的node模块。&lt;/p&gt;

&lt;p&gt;例如，uglifyJSPlugin获取bundle.js然后压缩和混淆内容以减小文件体积。&lt;/p&gt;

&lt;p&gt;类似的extract-text-webpack-plugin内部使用css-loader和style-loader来收集所有的css到一个地方最终将结果提取结果到一个独立的”styles.css“文件，并且在html里边引用style.css文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//webpack.config.js
// 获取所有的.css文件，合并它们的内容然后提取css内容到一个独立的”styles.css“里
var ETP = require(&amp;quot;extract-text-webpack-plugin&amp;quot;);

module: {
 loaders: [
  {test: /\.css$/, loader:ETP.extract(&amp;quot;style-loader&amp;quot;,&amp;quot;css-loader&amp;quot;) }
  ]
},
plugins: [
    new ExtractTextPlugin(&amp;quot;styles.css&amp;quot;) //Extract to styles.css file
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：如果你只是想把css使用style标签内联到html里，你不必使用extract-text-webpack-plugin，仅仅使用css loader和style loader即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module: {
 loaders: [{
  test: /\.css$/,
  loader: &#39;style!css&#39; // (short for style-loader!css-loader)
 }]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;加载器-loader-和插件&#34;&gt;加载器（loader）和插件&lt;/h2&gt;

&lt;p&gt;你可能已经意识到了，Loader处理单独的文件级别并且通常作用于包生成之前或生成的过程中。&lt;/p&gt;

&lt;p&gt;而插件则是处理包（bundle）或者chunk级别，且通常是bundle生成的最后阶段。一些插件如commonschunkplugin甚至更直接修改bundle的生成方式。&lt;/p&gt;

&lt;h2 id=&#34;处理文件的扩展名&#34;&gt;处理文件的扩展名&lt;/h2&gt;

&lt;p&gt;很多Webpack的配置文件都有一个resolve属性，然后就像下面代码所示有一个空字符串的值。空字符串在此是为了resolve一些在import文件时不带文件扩展名的表达式，如&lt;code&gt;require(&#39;./myJSFile&#39;)&lt;/code&gt;或者&lt;code&gt;import myJSFile from &#39;./myJSFile&#39;&lt;/code&gt;（译者注：实际就是自动添加后缀，默认是当成js文件来查找路径）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
 resolve: {
   extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.jsx&#39;]
 }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>npm学习笔记</title>
      <link>https://hestation.com/2016/npm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 16 May 2016 08:59:00 +0000</pubDate>
      
      <guid>https://hestation.com/2016/npm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;近期在做一个投票项目的应用时，突然发现对npm的认识很少，故查询了一些资料，现将自己的笔记总结在此。&lt;/p&gt;

&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;npm是Node.js的包管理工具&lt;/p&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看用户手册&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm -h
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;生成package.json
&lt;code&gt;bash
npm init
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;save-dev与-save的区别&#34;&gt;&amp;ndash;save-dev与&amp;ndash;save的区别&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;npm install module-name --save-dev&lt;/code&gt; // 把模块和版本号添加到dependencies部分&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install module-name --save&lt;/code&gt; // 把模块和版本号添加到devDependencies部分&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;devDependencies下列出的模块，是我们开发时用的，比如grunt-contrib-uglify，我们用它混淆js文件，它们不会被部署到生产环境。dependencies下的模块，则是我们生产环境中需要的依赖。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>前端学习笔记</title>
      <link>https://hestation.com/2016/xiachufang/</link>
      <pubDate>Wed, 13 Apr 2016 22:42:28 +0000</pubDate>
      
      <guid>https://hestation.com/2016/xiachufang/</guid>
      <description>

&lt;h2 id=&#34;问题一-外容器的尺寸未知-内容器已知-实现水平垂直居中&#34;&gt;问题一：外容器的尺寸未知,内容器已知，实现水平垂直居中&lt;/h2&gt;

&lt;h3 id=&#34;html结构&#34;&gt;html结构:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;方法一-绝对定位-负外边距&#34;&gt;方法一：绝对定位 + 负外边距&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.container {
    position: relative;
}
.item {
    width: 200px;
    height: 200px;
    position: absolute;
    top: 50%;
    left: 50%;
    margin: -100px 0 0 -100px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;方法二-绝对定位-四周偏移量定位0-外边距为auto&#34;&gt;方法二：绝对定位 + 四周偏移量定位0， 外边距为auto&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.container {
    position: relative;
}
.item {
    width: 200px;
    height: 200px;
    position: absolute;
    margin: auto;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;方法三-flex定位&#34;&gt;方法三：Flex定位&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.container {
    display: flex;
    justify-content: center;
    align-items: center;
}
.item {
    width: 200px;
    height: 200px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;方法四-css3-tramsform属性&#34;&gt;方法四： CSS3 tramsform属性&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.container {
    position: relative;
}
.item {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 200px;
    height: 200px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;方法五-tabel-cell&#34;&gt;方法五： tabel-cell&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.container {
    display: table-cell;
    text-align: center;
    vertical-align: middle;
}
.item {
    width: 200px;
    height: 200px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;问题二-实现固定导航栏&#34;&gt;问题二：实现固定导航栏&lt;/h2&gt;

&lt;h3 id=&#34;方法一-fixed固定定位&#34;&gt;方法一：fixed固定定位&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;固定导航栏&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        * {
            margin: 0;
            padding: 0;
        }
        body {
            height: 2000px;
            overflow-y: scroll;
        }
        .nav {
            position: fixed;
            width: 100%;
            height: 200px;
            top: 0;
            background-color: lightskyblue;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;nav&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;方法二-导航栏绝对定位-js监听滚动事件&#34;&gt;方法二：导航栏绝对定位，js监听滚动事件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function (){
    var nav = document.getElementsByClassName(&#39;nav&#39;),
        offTop = document.offsetTop,
        scrTop = document.documentElement.scrollTop || document.body.scrollTop;

    window.addEventListener(&#39;scroll&#39;, function () {

        if (scrTop &amp;gt; offTop) {
            nav.style.position = &#39;absolute&#39;;
            nav.style.top = scrTop;
            nav.style.margin = &#39;0&#39;;
        }
    }, false);
}());
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;问题三&#34;&gt;问题三&lt;/h2&gt;

&lt;p&gt;在Chrome的控制台运行&lt;code&gt;var log = console.log; log(123)&lt;/code&gt;，报错信息为：&lt;code&gt;Illegal invocation&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;错误原因&#34;&gt;错误原因：&lt;/h3&gt;

&lt;p&gt;console对象是JavaScript的原生对象,这里在全局范围内定义一个log函数，实际上在浏览器的工作环境下是给window全局变量添加了一个window.log()方法，实际执行的是window.log(123),故报错。&lt;/p&gt;

&lt;h3 id=&#34;一个可成功执行的log函数&#34;&gt;一个可成功执行的log函数：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var log = function (a) {
    console.log(a);
};

log(123);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;问题四&#34;&gt;问题四&lt;/h2&gt;

&lt;p&gt;不使用jQuery让方块B实现与方块A完全相同的效果。
由于没有研究过jQuery的源码，所以对其&lt;code&gt;.animate()&lt;/code&gt;的实现没有了解，查询资料后得知，&lt;code&gt;.animate(prop [, speed] [, easing] [, callback])&lt;/code&gt;接收四个参数，而题目中仅给了一个进行动画的样式，故&lt;code&gt;duration&lt;/code&gt;参数为默认值&lt;code&gt;400ms&lt;/code&gt;, &lt;code&gt;easing&lt;/code&gt;为默认值余弦动画&amp;rsquo;swing&amp;rsquo;
swing的动画函数为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;swing: function( p, n, firstNum, diff ) {
       return ( ( -Math.cos(p * Math.PI) / 2 ) + 0.5 ) * diff + firstNum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尝试后无法实现该余弦函数动画，以下是接近的非余弦的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function () {
    setInterval(function() {
        var b = document.getElementById(&#39;b&#39;);
        var speed = (500 - b.offsetLeft) / 15;
        speed = speed &amp;gt; 0 ? Math.ceil(speed) : Math.floor(speed);
        b.style.left = b.offsetLeft + speed + &#39;px&#39;;
    }, 13)
}());
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;问题五&#34;&gt;问题五&lt;/h2&gt;

&lt;p&gt;使用现代浏览器的 Promise 编写一个ajax工具函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * 一个ajax工具函数
 * @param {string} url - 请求的url
 * @param {string} method - 请求的method，GET、POST等
 * @return {Promise.&amp;lt;string|Error&amp;gt;}
 */
var ajax = function (url, method) {
    var promise = new Promise(function (resolve, reject) {
        var client = new XMLHttpRequest();
        client.open(method, url);
        client.onreadystatechange = handle;
        client.responseType = &#39;json&#39;;
        client.setRequestHeader(&#39;Accept&#39;, &#39;application/json&#39;);
        client.send();

        function handle() {
            if (this.readyState !== 4) {
                return;
            }
            if (this.status &amp;gt;= 200 &amp;amp;&amp;amp; this.status &amp;lt; 300) {
                resolve(this.response);
            } else {
                reject(new Error(this.statusText));
            }
        }
    });

    return promise;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;问题六&#34;&gt;问题六&lt;/h2&gt;

&lt;p&gt;最近在读阮一峰老师的《ES6标准入门》一书，因为近期在跟着做百度ife前端学院的春季任务，希望一边学习使用ES6的新语法糖完成，目前用的比较多的有箭头函数、解构赋值、let等。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Webpack使用</title>
      <link>https://hestation.com/2016/webpack%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</link>
      <pubDate>Sat, 09 Apr 2016 11:55:55 +0000</pubDate>
      
      <guid>https://hestation.com/2016/webpack%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;最近在做百度前端技术学院的任务时，尝试接触使用了ES6新的语法糖，在这过程中，也顺便学习了一下近期很火的webpac的使用，以下是对近期学习的一个总结与归纳。&lt;/p&gt;

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Webpack&lt;/code&gt;不同于&lt;code&gt;Gulp&lt;/code&gt;或者&lt;code&gt;Grunt&lt;/code&gt;，后者是一种自动化处理工具，而&lt;code&gt;Webpack&lt;/code&gt;是一个种模块化解决方案，名为&lt;code&gt;MODULE BUNDLER&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在 webpack 里，所有类型的文件都可以是模块，包含最常见的 JavaScript，以及 css 文件、图片、json 文件等等。通过 webpack 的各种加载器，可以更有效地管理这些文件。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;全局安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install webpack -g
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;本地安装
&lt;code&gt;bash
npm init
npm install webpack --save-dev
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看所有命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;webpack --help
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;webpack配置&#34;&gt;Webpack配置&lt;/h2&gt;

&lt;p&gt;Webpack默认的配置文件名称为&lt;code&gt;webpack.config.js&lt;/code&gt;，其中包含了一个&lt;code&gt;entry&lt;/code&gt;入口和一个&lt;code&gt;output&lt;/code&gt;出口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// webpack.config.js
module.exports = {
entry: &#39;./main.js&#39;,
output: {
filename: &#39;bundle.js&#39;
}
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在创建好&lt;code&gt;webpack.config.js&lt;/code&gt;文件后，直接使用&lt;code&gt;webpack&lt;/code&gt;命令即可，下面是命令的几种模式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;webpack // 构建为开发环境输出
webpack -p // 构建为生产环境输出（压缩混淆脚本）
webpack --watch // 监听变动并自动打包
webpack -d // 生成map映射文件，告知哪些模块被最终打包到哪里了
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;模块化&#34;&gt;模块化&lt;/h2&gt;

&lt;h3 id=&#34;模块化javascript&#34;&gt;模块化JavaScript&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装babel-loader&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install babel-loader babel-core babel-preset-es2015 --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;配置 &lt;code&gt;webpack.config.js&lt;/code&gt;
在 &lt;code&gt;module.exports&lt;/code&gt; 值中添加 module：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
entry: {
app: [&#39;./main.js&#39;]
},
output: {
filename: &#39;bundle.js&#39;
},
module: {
loaders: [{
    test: /\.js$/,
    loaders: [&#39;babel?presets[]=es2015&#39;],
    exclude: /node_modules/
}]
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;css加载器&#34;&gt;CSS加载器&lt;/h3&gt;

&lt;p&gt;我们可以按传统方法使用 CSS，即在 HTML 文件中添加：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;style/app.css&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但 webpack 里，CSS 同样可以模块化，使用 import 导入。&lt;/p&gt;

&lt;p&gt;因此我们不再使用 link 标签来引用 CSS，而是通过 webpack 的 &lt;a href=&#34;https://github.com/webpack/style-loader&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;style-loader&lt;/a&gt; 及 &lt;a href=&#34;https://github.com/webpack/css-loader&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;css-loader&lt;/a&gt;。前者将 css 文件以 &lt;code&gt;&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;&lt;/code&gt; 标签插入 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 头部，后者负责解读、加载 CSS 文件。&lt;/p&gt;

&lt;h4 id=&#34;安装-css-相关的加载器&#34;&gt;安装 CSS 相关的加载器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install style-loader css-loader --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;配置-webpack-config-js-文件&#34;&gt;配置 webpack.config.js 文件&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
// ...
module: {
    loaders: [
        { test: /\.css$/, loaders: [&#39;style&#39;, &#39;css&#39;] }
    ]
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;在-main-js-文件中引入-css&#34;&gt;在 main.js 文件中引入 css&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import&#39;./style/app.css&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，在执行 &lt;code&gt;webpack&lt;/code&gt; 后，我们的 CSS 文件就会被打包进 &lt;code&gt;bundle.js&lt;/code&gt; 文件中，如果不想它们被打包进去，可以使用 &lt;a href=&#34;https://github.com/webpack/extract-text-webpack-plugin&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;extract text&lt;/a&gt;扩展。&lt;/p&gt;

&lt;h3 id=&#34;autoprefixer&#34;&gt;autoprefixer&lt;/h3&gt;

&lt;p&gt;我们在写 CSS 时，按 CSS 规范写，构建时利用 autoprefixer 可以输出 -webkit、-moz 这样的浏览器前缀，webpack 同样是通过 loader 提供该功能。&lt;/p&gt;

&lt;h4 id=&#34;安装-autoprefixer-loader&#34;&gt;安装 autoprefixer-loader&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install autoprefixer-loader --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;配置-webpack-config-js&#34;&gt;配置 webpack.config.js&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;loaders: [{
test: /\.css$/,
loader: &#39;style!css!autoprefixer?{browsers:[&amp;quot;last 2 version&amp;quot;, &amp;quot;&amp;gt; 1%&amp;quot;]}&#39;,
//...
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;完整示例&#34;&gt;完整示例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var webpack = require(&#39;webpack&#39;);
var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&#39;common.js&#39;);

module.exports = {
    //插件项
    plugins: [commonsPlugin],
    //页面入口文件配置
    entry: {
        index : &#39;./src/js/page/index.js&#39;
    },
    //入口文件输出配置
    output: {
        path: &#39;dist/js/page&#39;,
        filename: &#39;[name].js&#39;
    },
    module: {
        //加载器配置
        loaders: [
            //.css 文件使用 style-loader 和 css-loader 来处理
            { test: /\.css$/, loader: &#39;style-loader!css-loader&#39; },
            //.js 文件使用 jsx-loader 来编译处理
            { test: /\.js$/, loader: &#39;jsx-loader?harmony&#39; },
            //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理
            { test: /\.scss$/, loader: &#39;style!css!sass?sourceMap&#39;},
            //图片文件使用 url-loader 来处理，小于8kb的直接转为base64
            { test: /\.(png|jpg)$/, loader: &#39;url-loader?limit=8192&#39;}
        ]
    }
    //其它解决方案配置
    resolve: {
        root: &#39;E:/github/flux-example/src&#39;, //绝对路径
        extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.scss&#39;],
        alias: {
            AppStore : &#39;js/stores/AppStores.js&#39;,
            ActionType : &#39;js/actions/ActionType.js&#39;,
            AppAction : &#39;js/actions/AppAction.js&#39;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ES6学习笔记（一）：Set和Map</title>
      <link>https://hestation.com/2016/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80set%E5%92%8Cmap/</link>
      <pubDate>Tue, 05 Apr 2016 20:58:41 +0000</pubDate>
      
      <guid>https://hestation.com/2016/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80set%E5%92%8Cmap/</guid>
      <description>

&lt;h2 id=&#34;set&#34;&gt;Set&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://7xkus6.com1.z0.glb.clouddn.com/ES6-Set.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;es6利用set数组去重&#34;&gt;ES6利用Set数组去重：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;方法一：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function dedupe(array) {
  return Array.from(new Set(array));
}

dedupe([1, 1, 2, 3]); // [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;方法二(利用扩展运算符)：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)];
// [3, 5, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;特性&#34;&gt;特性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Set结构没有键名，只有键值，所以&lt;code&gt;keys()&lt;/code&gt;和&lt;code&gt;values()&lt;/code&gt;的行为完全一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);

for (let item of set.keys()) {
    console.log(item);
}
// red
// green
// blue

for (let item of set.values()) {
    console.log(item);
}
//red
//green
//blue

for (let item of set.entries()) {
    console.log(item);
}
// [&amp;quot;red&amp;quot;, &amp;quot;red&amp;quot;]
// [&amp;quot;green&amp;quot;, &amp;quot;green&amp;quot;]
// [&amp;quot;blue&amp;quot;, &amp;quot;blue&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;可以省略&lt;code&gt;values()&lt;/code&gt;方法，直接用&lt;code&gt;for...of&lt;/code&gt;循环遍历Set，因为其默认遍历器生成函数就是它的&lt;code&gt;values()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Set.prototype[Symbol.iterator] === Set.prototype.values
//true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###　Set实现并集、交集、差集&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

//并集
let union = new Set([...a, ...b]);
//[1, 2, 3, 4]

//交集
let intersect = new Set([...a].filter(x =&amp;gt; b.has(x)));
//[2, 3]

//差集
let difference = new Set([...a].filter(x =&amp;gt; !b.has(x)));
//[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;map&#34;&gt;Map&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://7xkus6.com1.z0.glb.clouddn.com/ES6-Map.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;和对象类似，&lt;code&gt;Object&lt;/code&gt;结构提供了&lt;code&gt;“字符串-值”&lt;/code&gt;的对应，Map结构提供了&lt;code&gt;“值-值”&lt;/code&gt;的对应，是一种更完善的Hash结构实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;map和其他数据结构的转换&#34;&gt;Map和其他数据结构的转换&lt;/h3&gt;

&lt;h4 id=&#34;map-array&#34;&gt;Map -&amp;gt; Array&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let myMap = new Map().set(true, 7).set({foo: 3}, [&#39;abc&#39;]);
[...myMap];
// [[true, 7], [{foo: 3}, [&#39;abc&#39;]]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;array-map&#34;&gt;Array -&amp;gt; Map&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;new Map([[true, 7], [{foo: 3}, [&#39;abc&#39;]]])
// Map {true =&amp;gt; 7, Object {foo: 3} =&amp;gt; [&#39;abc&#39;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;map-object&#34;&gt;Map -&amp;gt; Object&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function strMapToObj(strMap) {
    let obj = Object.create(null);
    for (let [k,v] of strMap) {
        obj[k] = v;
    }
    return obj;
}

let myMap = new Map().set(&#39;yes&#39;, true).set(&#39;no&#39;, false);
strMapToObj(myMap)
// { yes: true, no: false }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;object-map&#34;&gt;Object -&amp;gt; Map&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function objToStrMap(obj) {
    let strMap = new Map();
    for (let k of Object.keys(obj)) {
        strMap.set(k, obj[k]);
    }
    return strMap;
}

objToStrMap({yes: true, no: false})
// [ [ &#39;yes&#39;, true ], [ &#39;no&#39;, false ] ]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>前端构建工具Gulp</title>
      <link>https://hestation.com/2016/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7gulp/</link>
      <pubDate>Thu, 24 Mar 2016 22:32:00 +0000</pubDate>
      
      <guid>https://hestation.com/2016/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7gulp/</guid>
      <description>

&lt;h2 id=&#34;第一步-安装node&#34;&gt;第一步：安装Node&lt;/h2&gt;

&lt;p&gt;首先需要搭建node环境。访问&lt;a href=&#34;http://nodejs.org&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Node.js官网&lt;/a&gt;，然后点击大大的绿色的install按钮，下载完成后直接运行程序，就一切准备就绪。npm会随着安装包一起安装，稍后会用到它。&lt;/p&gt;

&lt;h2 id=&#34;第二步-使用命令行&#34;&gt;第二步：使用命令行&lt;/h2&gt;

&lt;p&gt;查看node版本号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;node -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看npm版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm -v
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第三步-安装gulp&#34;&gt;第三步：安装gulp&lt;/h2&gt;

&lt;p&gt;NPM是基于命令行的node包管理工具，它可以将node的程序模块安装到项目中，在它的官网中可以查看和搜索所有可用的程序模块。
在命令行中输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo npm install -g gulp
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;sudo是以管理员身份执行命令，一般会要求输入电脑密码&lt;/li&gt;
&lt;li&gt;npm是安装node模块的工具，执行install命令&lt;/li&gt;
&lt;li&gt;-g表示在全局环境安装，以便任何项目都能使用它&lt;/li&gt;
&lt;li&gt;最后，gulp是将要安装的node模块的名字&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运行时注意查看命令行有没有错误信息，安装完成后，你可以使用下面的命令查看gulp的版本号以确保gulp已经被正确安装。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gulp -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们需要将gulp安装到项目本地&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install —-save-dev gulp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，我们使用*&amp;ndash;save-dev*来更新package.json文件，更新*devDependencies*值，以表明项目需要依赖gulp。&lt;/p&gt;

&lt;p&gt;Dependencies可以向其他参与项目的人指明项目在开发环境和生产环境中的node模块依懒关系，想要更加深入的了解它可以看看&lt;a href=&#34;https://npmjs.org/doc/json.html#dependencies&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;package.json文档&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;第四步-新建gulpfile文件-运行gulp&#34;&gt;第四步：新建Gulpfile文件，运行gulp&lt;/h2&gt;

&lt;p&gt;安装好gulp后我们需要告诉它要为我们执行哪些任务，首先，我们自己需要弄清楚项目需要哪些任务。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查Javascript&lt;/li&gt;
&lt;li&gt;编译Sass（或Less之类的）文件&lt;/li&gt;
&lt;li&gt;合并Javascript&lt;/li&gt;
&lt;li&gt;压缩并重命名合并后的Javascript&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;安装依赖&#34;&gt;安装依赖&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install gulp-jshint gulp-sass gulp-concat gulp-uglify gulp-rename --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;提醒下，如果以上命令提示权限错误，需要添加sudo再次尝试。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;新建gulpfile文件&#34;&gt;新建gulpfile文件&lt;/h3&gt;

&lt;p&gt;现在，组件都安装完毕，我们需要新建gulpfile文件以指定gulp需要为我们完成什么任务。&lt;/p&gt;

&lt;p&gt;gulp只有五个方法： *task*，*run*，*watch*，*src*，和*dest*，在项目根目录新建一个js文件并命名为*gulpfile.js*，把下面的代码粘贴进去：&lt;/p&gt;

&lt;h4 id=&#34;gulpfile-js&#34;&gt;gulpfile.js&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 引入 gulp
var gulp = require(&#39;gulp&#39;);

// 引入组件
var jshint = require(&#39;gulp-jshint&#39;);
var sass = require(&#39;gulp-sass&#39;);
var concat = require(&#39;gulp-concat&#39;);
var uglify = require(&#39;gulp-uglify&#39;);
var rename = require(&#39;gulp-rename&#39;);

// 检查脚本
gulp.task(&#39;lint&#39;, function() {
    gulp.src(&#39;./js/*.js&#39;)
        .pipe(jshint())
        .pipe(jshint.reporter(&#39;default&#39;));
});

// 编译Sass
gulp.task(&#39;sass&#39;, function() {
    gulp.src(&#39;./scss/*.scss&#39;)
        .pipe(sass())
        .pipe(gulp.dest(&#39;./css&#39;));
});

// 合并，压缩文件
gulp.task(&#39;scripts&#39;, function() {
    gulp.src(&#39;./js/*.js&#39;)
        .pipe(concat(&#39;all.js&#39;))
        .pipe(gulp.dest(&#39;./dist&#39;))
        .pipe(rename(&#39;all.min.js&#39;))
        .pipe(uglify())
        .pipe(gulp.dest(&#39;./dist&#39;));
});

// 默认任务
gulp.task(&#39;default&#39;, function(){
    gulp.run(&#39;lint&#39;, &#39;sass&#39;, &#39;scripts&#39;);

    // 监听文件变化
    gulp.watch(&#39;./js/*.js&#39;, function(){
        gulp.run(&#39;lint&#39;, &#39;sass&#39;, &#39;scripts&#39;);
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，分段解释下这段代码。&lt;/p&gt;

&lt;h3 id=&#34;引入组件&#34;&gt;引入组件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var gulp = require(&#39;gulp&#39;);
var jshint = require(&#39;gulp-jshint&#39;);
var sass = require(&#39;gulp-sass&#39;);
var concat = require(&#39;gulp-concat&#39;);
var uglify = require(&#39;gulp-uglify&#39;);
var rename = require(&#39;gulp-rename&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一步，我们引入了核心的gulp和其他依赖组件，接下来，分开创建lint, sass, scripts 和 default这四个不同的任务。&lt;/p&gt;

&lt;h3 id=&#34;lint任务&#34;&gt;Lint任务&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;gulp.task(&#39;lint&#39;, function() {
    gulp.src(&#39;./js/*.js&#39;)
        .pipe(jshint())
        .pipe(jshint.reporter(&#39;default&#39;));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Link任务会检查js/目录下得js文件有没有报错或警告。&lt;/p&gt;

&lt;h3 id=&#34;sass任务&#34;&gt;Sass任务&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;gulp.task(&#39;sass&#39;, function() {
    gulp.src(&#39;./scss/*.scss&#39;)
        .pipe(sass())
        .pipe(gulp.dest(&#39;./css&#39;));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sass任务会编译scss/目录下的scss文件，并把编译完成的css文件保存到/css目录中。&lt;/p&gt;

&lt;h3 id=&#34;scripts-任务&#34;&gt;Scripts 任务&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;gulp.task(&#39;scripts&#39;, function() {
    gulp.src(&#39;./js/*.js&#39;)
        .pipe(concat(&#39;all.js&#39;))
        .pipe(gulp.dest(&#39;./dist&#39;))
        .pipe(rename(&#39;all.min.js&#39;))
        .pipe(uglify())
        .pipe(gulp.dest(&#39;./dist&#39;));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;scripts任务会合并js/目录下得所有得js文件并输出到dist/目录，然后gulp会重命名、压缩合并的文件，也输出到dist/目录。&lt;/p&gt;

&lt;h3 id=&#34;default任务&#34;&gt;default任务&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;gulp.task(&#39;default&#39;, function(){
    gulp.run(&#39;lint&#39;, &#39;sass&#39;, &#39;scripts&#39;);
    gulp.watch(&#39;./js/*.js&#39;, function(){
        gulp.run(&#39;lint&#39;, &#39;sass&#39;, &#39;scripts&#39;);
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时，我们创建了一个基于其他任务的default任务。使用.run()方法关联和运行我们上面定义的任务，使用.watch()方法去监听指定目录的文件变化，当有文件变化时，会运行回调定义的其他任务。&lt;/p&gt;

&lt;p&gt;现在，回到命令行，可以直接运行gulp任务了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gulp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将执行定义的default任务，换言之，这和以下的命令式同一个意思&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gulp default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，我们可以运行在*gulpfile.js*中定义的任意任务，比如，现在运行sass任务：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gulp sass
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>